{
    "1": "Question: `Write a Python function to BFS on a graph.`\r\n\r\n--Test Cases Start--\r\n```python\r\ndef test_solution(solution):\r\n    passed = []\r\n    not_passed = []\r\n\r\n    # Define a simple graph using adjacency list representation\r\n    class Graph:\r\n        def __init__(self):\r\n            self.graph = {}\r\n\r\n        def add_edge(self, u, v):\r\n            if u not in self.graph:\r\n                self.graph[u] = []\r\n            if v not in self.graph:\r\n                self.graph[v] = []\r\n            self.graph[u].append(v)\r\n            self.graph[v].append(u)  # For undirected graph\r\n\r\n    # Test case 1: Basic BFS on a simple graph\r\n    g1 = Graph()\r\n    g1.add_edge(0, 1)\r\n    g1.add_edge(0, 2)\r\n    g1.add_edge(1, 3)\r\n    g1.add_edge(1, 4)\r\n    g1.add_edge(2, 5)\r\n    expected_result1 = [0, 1, 2, 3, 4, 5]\r\n    if solution(g1.graph, 0) == expected_result1:\r\n        passed.append(\"Solution has passed test case 1 with expected result: \" + str(expected_result1))\r\n    else:\r\n        not_passed.append(\"Solution has not passed test case 1 with expected result: \" + str(expected_result1))\r\n\r\n    # Test case 2: BFS on a disconnected graph\r\n    g2 = Graph()\r\n    g2.add_edge(0, 1)\r\n    g2.add_edge(0, 2)\r\n    g2.add_edge(3, 4)\r\n    expected_result2 = [3, 4]  # Starting BFS from node 3\r\n    if solution(g2.graph, 3) == expected_result2:\r\n        passed.append(\"Solution has passed test case 2 with expected result: \" + str(expected_result2))\r\n    else:\r\n        not_passed.append(\"Solution has not passed test case 2 with expected result: \" + str(expected_result2))\r\n\r\n    # Test case 3: BFS on a single node graph\r\n    g3 = Graph()\r\n    g3.add_edge(0, 0)  # Self-loop\r\n    expected_result3 = [0]\r\n    if solution(g3.graph, 0) == expected_result3:\r\n        passed.append(\"Solution has passed test case 3 with expected result: \" + str(expected_result3))\r\n    else:\r\n        not_passed.append(\"Solution has not passed test case 3 with expected result: \" + str(expected_result3))\r\n\r\n    # Test case 4: BFS on an empty graph\r\n    g4 = Graph()\r\n    expected_result4 = []  # No nodes to traverse\r\n    if solution(g4.graph, 0) == expected_result4:\r\n        passed.append(\"Solution has passed test case 4 with expected result: \" + str(expected_result4))\r\n    else:\r\n        not_passed.append(\"Solution has not passed test case 4 with expected result: \" + str(expected_result4))\r\n\r\n    return passed, not_passed\r\n```\r\n--Test Cases End--\r\n\r\n--Constrains Start--\r\n- The Function should be named 'solution'.\r\n- The Function should take a graph represented as an adjacency list (dictionary) and a starting node as input.\r\n- The Function should output a list of nodes in the order they were visited during the BFS traversal.\r\n--Constrains End--"
}